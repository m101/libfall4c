diff --git a/pathfinding.c b/pathfinding.c
index 04c28d5..52a097f 100755
--- a/pathfinding.c
+++ b/pathfinding.c
@@ -80,7 +80,7 @@ Position * AStar_Search(Position Start, Position Goal, Unite Unit)
 }
 */
 
-struct List* path_find_astar (struct t_position Depart, struct t_position Arrivee) //, t_unit Unite)
+struct List* path_find_astar (struct t_position Depart, struct t_position Arrivee)
 {
     struct List *Arbre = NULL;
     struct List *NodeCostLowestArbre = NULL;
@@ -235,7 +235,7 @@ struct List* path_find_astar (struct t_position Depart, struct t_position Arrive
     return Arbre;
 }
 
-long path_calcul_manhattan_heuristic (struct t_position Depart, struct t_position Arrivee)// , t_unit Unite)
+long path_heuristic_manhattan (struct t_position Depart, struct t_position Arrivee)
 {
     struct t_position Manhattan = {0, 0};
     long manhattan = 0;
@@ -247,10 +247,10 @@ long path_calcul_manhattan_heuristic (struct t_position Depart, struct t_positio
     return manhattan;
 }
 
-/*! @brief Find the lowest cost
-*   @param Noeud Node to check for lowest cost
+/*! @brief              Find the lowest cost
+*   @param Node         Node to check for lowest cost
 */
-struct List* path_find_lowestcost (struct List *Noeud)
+struct List* path_find_lowestcost (struct List *Node)
 {
     struct List *l_lowestCostNode = Noeud;
     struct List *NoeudCurrent = Noeud;
@@ -261,7 +261,7 @@ struct List* path_find_lowestcost (struct List *Noeud)
 
     while (NoeudCurrent != NULL)
     {
-        printf("Noeud courrant; x : %ld, y : %ld\n",\
+        printf("Current node - x : %ld, y : %ld\n",\
                ((struct t_path_node *)(NoeudCurrent->data))->Position.x,\
                ((struct t_path_node *)(NoeudCurrent->data))->Position.y);
         printf("G cost : %ld\n", ((struct t_path_node *)(NoeudCurrent->data))->costFromStart);
@@ -282,9 +282,10 @@ struct List* path_find_lowestcost (struct List *Noeud)
     return l_lowestCostNode;
 }
 
-struct List* path_find_noeud (struct List *Liste, struct t_position Position)
+// find a node according to it's position
+struct List* path_find_node (struct List *List, struct t_position Position)
 {
-    struct List *NodeCurrent = Liste;
+    struct List *NodeCurrent = List;
     struct List *NodeReturned = NULL;
 
     while (NodeCurrent != NULL)
@@ -302,165 +303,119 @@ struct List* path_find_noeud (struct List *Liste, struct t_position Position)
     return NodeReturned;
 }
 
-struct List* path_ajouter_noeud_liste (struct List *Liste, struct List *AppendedListe)
+// append a node to path
+int path_list_node_add (struct List *List, struct List *Node)
 {
-    struct List *ListNode = Liste, *ListLastNode = NULL;
-    /*
-    if (Liste != NULL)
-        Liste->next = AppendedListe;
-    */
-    // On recherche le dernier noeud de la liste
-    while (ListNode)
-    {
-        ListLastNode = ListNode;
-        ListNode = ListNode->next;
-    }
-    printf("path_ajouter_noeud_liste : %p\n", ListLastNode);
-    // Si la liste a "aPend" n'est pas nulle
-    // Alors on verifie si la liste contenante n'est pas nulle
-    if ((AppendedListe != NULL) && (AppendedListe != Liste))
-    {
-        // Si le dernier element de la liste n'est pas nul
-        // Alors on ajoute le noeud en parametre à la suite de celui-ci
-        if (ListLastNode != NULL)
-        {
-            ListLastNode->next = AppendedListe;
-            AppendedListe->prev = ListLastNode;
-            AppendedListe->next = NULL;
-        }
-    }
+        return list_append_node (List, Node);
+}
 
-    return Liste;
+// remove a node from path
+int path_list_node_delete (struct List *Node)
+{
+        list_remove_node (Node);
 }
 
-struct List* path_enlever_noeud_liste (struct List *Liste, struct List *AppendedListe)
+// convert a path node to a list
+struct List* path_node_to_list (struct t_path_node *Node)
 {
-    struct List *ListPrev = NULL, *ListNext = NULL;
-    struct List *NoeudForward = NULL, *NoeudBackward = Liste;
+        struct List *List;
 
-    if ( (AppendedListe != NULL) )
-    {
-        ListPrev = AppendedListe->prev;
-        ListNext = AppendedListe->next;
+        if (!Node)
+                return NULL;
 
-        if ( (ListPrev != NULL) && (ListNext != NULL) )
+        List = list_new ();
+
+        if (List != NULL)
         {
-            for (NoeudForward = Liste; NoeudForward != NULL;\
-                    NoeudForward = NoeudForward->next)
-            {
-                if ( (NoeudForward == AppendedListe)
-                        || (NoeudBackward == AppendedListe) )
-                {
-                    // On enleve le premier element
-                    if (ListPrev == NULL)
-                    {
-                        AppendedListe->next = NULL;
-                        ListNext->prev = NULL;
-                    }
-                    // On enleve le dernier element
-                    else if (ListNext == NULL)
-                    {
-                        AppendedListe->prev = NULL;
-                        ListPrev->next = NULL;
-                    }
-                    // On enlève les autres noeuds
-                    else
-                    {
-                        ListPrev->next = ListNext;
-                        ListNext->prev = ListPrev;
-                    }
-                    break;
-                }
-                if (NoeudBackward != NULL)
-                    NoeudBackward = NoeudBackward->prev;
-            }
+                ((struct t_path_node *)(List->data))->Position.x = Node->Position.x;
+                ((struct t_path_node *)(List->data))->Position.y = Node->Position.y;
+                ((struct t_path_node *)(List->data))->ParentNodePoint.x = Node->ParentNodePoint.x;
+                ((struct t_path_node *)(List->data))->ParentNodePoint.y = Node->ParentNodePoint.y;
+                ((struct t_path_node *)(List->data))->type = Node->type;
+                ((struct t_path_node *)(List->data))->poids = Node->poids;
+                ((struct t_path_node *)(List->data))->direction = Node->direction;
+                ((struct t_path_node *)(List->data))->cost = Node->cost;
+                ((struct t_path_node *)(List->data))->costFromStart = Node->costFromStart;
+                ((struct t_path_node *)(List->data))->costToGoal_heuristic = Node->costToGoal_heuristic;
+                ((struct t_path_node *)(List->data))->isOpen = Node->isOpen;
         }
-    }
 
-    return Liste;
+        return List;
 }
 
-void path_mov_node_to_list (struct List *Liste, struct t_path_node Node)
+// convert a list to a path node
+struct t_path_node* path_list_to_node (struct List *List)
 {
-    if (Liste != NULL)
-    {
-        ((struct t_path_node *)(Liste->data))->Position.x = Node.Position.x;
-        ((struct t_path_node *)(Liste->data))->Position.y = Node.Position.y;
-        ((struct t_path_node *)(Liste->data))->ParentNodePoint.x = Node.ParentNodePoint.x;
-        ((struct t_path_node *)(Liste->data))->ParentNodePoint.y = Node.ParentNodePoint.y;
-        ((struct t_path_node *)(Liste->data))->type = Node.type;
-        ((struct t_path_node *)(Liste->data))->poids = Node.poids;
-        ((struct t_path_node *)(Liste->data))->direction = Node.direction;
-        ((struct t_path_node *)(Liste->data))->cost = Node.cost;
-        ((struct t_path_node *)(Liste->data))->costFromStart = Node.costFromStart;
-        ((struct t_path_node *)(Liste->data))->costToGoal_heuristic = Node.costToGoal_heuristic;
-        ((struct t_path_node *)(Liste->data))->isOpen = Node.isOpen;
-    }
-}
+        struct t_path_node *Node;
+        
+        if (!List)
+                return NULL;
 
-void path_mov_list_to_node (struct t_path_node *Node, struct List *Liste)
-{
-    if ( (Liste != NULL) && (Node != NULL) )
-    {
-        Node->Position.x = ((struct t_path_node *)(Liste->data))->Position.x;
-        Node->Position.y = ((struct t_path_node *)(Liste->data))->Position.y;
-        Node->ParentNodePoint.x = ((struct t_path_node *)(Liste->data))->ParentNodePoint.x;
-        Node->ParentNodePoint.y = ((struct t_path_node *)(Liste->data))->ParentNodePoint.y;
-        Node->type = ((struct t_path_node *)(Liste->data))->type;
-        Node->poids = ((struct t_path_node *)(Liste->data))->poids;
-        Node->direction = ((struct t_path_node *)(Liste->data))->direction;
-        Node->cost = ((struct t_path_node *)(Liste->data))->cost;
-        Node->costFromStart = ((struct t_path_node *)(Liste->data))->costFromStart;
-        Node->costToGoal_heuristic = ((struct t_path_node *)(Liste->data))->costToGoal_heuristic;
-        Node->isOpen = ((struct t_path_node *)(Liste->data))->isOpen;
-    }
+        Node = path_node_new ();
+
+        if ( (Liste != NULL) && (Node != NULL) )
+        {
+                Node->Position.x = ((struct t_path_node *)(List->data))->Position.x;
+                Node->Position.y = ((struct t_path_node *)(List->data))->Position.y;
+                Node->ParentNodePoint.x = ((struct t_path_node *)(List->data))->ParentNodePoint.x;
+                Node->ParentNodePoint.y = ((struct t_path_node *)(List->data))->ParentNodePoint.y;
+                Node->type = ((struct t_path_node *)(List->data))->type;
+                Node->poids = ((struct t_path_node *)(List->data))->poids;
+                Node->direction = ((struct t_path_node *)(List->data))->direction;
+                Node->cost = ((struct t_path_node *)(List->data))->cost;
+                Node->costFromStart = ((struct t_path_node *)(List->data))->costFromStart;
+                Node->costToGoal_heuristic = ((struct t_path_node *)(List->data))->costToGoal_heuristic;
+                Node->isOpen = ((struct t_path_node *)(List->data))->isOpen;
+        }
+
+        return Node;
 }
 
-struct List* path_tri_liste (struct List *Liste)
+struct List* path_sort_list (struct List *Liste)
 {
-    struct List *CurrentNode = NULL;
-    struct List *TempNode = NULL;
-    long min = 0;
+        struct List *CurrentNode = NULL;
+        struct List *TempNode = NULL;
+        long min = 0;
 
-    if (Liste != NULL)
-        min = ((struct t_path_node *)(Liste->data))->cost;
+        if (Liste != NULL)
+                min = ((struct t_path_node *)(Liste->data))->cost;
 
-    for (CurrentNode = Liste; CurrentNode != NULL; CurrentNode = CurrentNode->next)
-    {
-        if (((struct t_path_node *)(CurrentNode->data))->cost < min)
+        for (CurrentNode = Liste; CurrentNode != NULL; CurrentNode = CurrentNode->next)
         {
-            min = ((struct t_path_node *)(CurrentNode->data))->cost;
-            TempNode = CurrentNode->next;
-            CurrentNode->next = CurrentNode;
-            CurrentNode->prev = TempNode;
+                if (((struct t_path_node *)(CurrentNode->data))->cost < min)
+                {
+                        min = ((struct t_path_node *)(CurrentNode->data))->cost;
+                        TempNode = CurrentNode->next;
+                        CurrentNode->next = CurrentNode;
+                        CurrentNode->prev = TempNode;
+                }
         }
-    }
 
-    return Liste;
+        return Liste;
 }
 
 void path_node_zero (struct t_path_node *Node)
 {
-    if (Node != NULL)
-    {
-        Node->Position.x = 0;
-        Node->Position.y = 0;
-        // Noeud parent
-        Node->ParentNodePoint.x = 0;
-        Node->ParentNodePoint.y = 0;
-        Node->type = 0;
-        Node->poids = 0;
-        Node->direction = 0;
-        // Manhattan : F = G + H
-        // F : Cout estimer
-        // G : Cout a partir du point de depart
-        // H : Cout "heuristique" jusqu'a l'arrivee
-        Node->cost = 0;                   // F
-        Node->costFromStart = 0;          // G
-        Node->costToGoal_heuristic = 0;   // H
-        Node->costNode = 0;
-        Node->isOpen = 0;
-    }
+        if (Node != NULL)
+        {
+                Node->Position.x = 0;
+                Node->Position.y = 0;
+                // Noeud parent
+                Node->ParentNodePoint.x = 0;
+                Node->ParentNodePoint.y = 0;
+                Node->type = 0;
+                Node->poids = 0;
+                Node->direction = 0;
+                // Manhattan : F = G + H
+                // F : Cout estimer
+                // G : Cout a partir du point de depart
+                // H : Cout "heuristique" jusqu'a l'arrivee
+                Node->cost = 0;                   // F
+                Node->costFromStart = 0;          // G
+                Node->costToGoal_heuristic = 0;   // H
+                Node->costNode = 0;
+                Node->isOpen = 0;
+        }
 }
 
 // Tri Liste Open
diff --git a/pathfinding.h b/pathfinding.h
index 2196326..3f5b0e6 100755
--- a/pathfinding.h
+++ b/pathfinding.h
@@ -9,16 +9,16 @@
 struct path_node
 {
     struct t_position Position;
-    // Noeud parent
+    // Parent node
     struct t_position ParentNodePoint;
     struct List *ParentNodestruct List;
     long type;
-    long poids;
+    long weigth;
     long direction;
     // Manhattan : F = G + H
-    // F : Cout estimer
-    // G : Cout a partir du point de depart
-    // H : Cout "heuristique" jusqu'a l'arrivee
+    // F : Estimated cost
+    // G : Cost from starting position
+    // H : Cost heuristic to arrival
     long cost;                   // F
     long costFromStart;          // G
     long costToGoal_heuristic;   // H
@@ -28,21 +28,33 @@ struct path_node
 
 /* A Star : Pathfinding
 */
-struct List* path_find_astar (struct t_position Depart, struct t_position Arrivee); //, t_unit Unite);
-long path_calcul_manhattan_heuristic (struct t_position Depart, struct t_position Arrivee); //, t_unit Unite);
+// pathfinding : A*
+struct List* path_find_astar (struct t_position Start, struct t_position Arrival);
+
+// pathfinding heuristic : manhattan
+long path_heuristic_manhattan (struct t_position Start, struct t_position Arrival);
+
+// find the lowest cost
 struct List* path_find_lowestcost (struct List *Noeud);
-// Ajouter un noeud a la struct Liste chainee
-struct List* path_ajouter_noeud_struct Liste (struct List *List, struct List *Appendedstruct Liste);
-// Enlever un noeud a la struct Liste chainee
-struct List* path_enlever_noeud_struct Liste (struct List *List, struct List *Appendedstruct Liste);
-// "Stocker" un t_path_node dans la struct Liste
-void path_mov_node_to_struct List (struct List *List, t_path_node Node);
-// "Stocker" une struct Liste dans un t_path_node
-void path_mov_struct List_to_node (t_path_node *Node, struct List *List);
-// Trouve un noeud selon sa position (x, y)
-struct List* path_find_noeud (struct List *List, struct t_position Position);
-// Tri de la struct Liste par cout
-struct List* path_tri_struct Liste (struct List *List);
+
+// append a node to path
+int path_list_node_add (struct List *List, struct List *Node);
+
+// remove a node from path
+int path_list_node_delete (struct List *Node);
+
+// convert a path node to a list
+struct List* path_node_to_list (struct t_path_node *Node)
+
+// convert a list to a path node
+struct t_path_node* path_list_to_node (struct List *List)
+
+// find a node according to it's position
+struct List* path_find_node (struct List *List, struct t_position Position);
+
+// sort path nodes according to cost
+struct List* path_sort_list (struct List *List);
+
 // Initialisation d'un t_path_node
 void path_node_zero (t_path_node *Node);
 
